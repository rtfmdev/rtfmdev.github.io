<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RTFM DevOps</title>
    <link>https://rtfmdev.github.io/docs/kubernetes/</link>
    <description>Recent content on RTFM DevOps</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://rtfmdev.github.io/docs/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/kubectl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/kubectl/</guid>
      <description>kubectl cheatsheet Connection details To look at the connection details, we can either see the content of the ~/.kube/config file (on Linux) or run the following command:
$ kubectl config view Cluster info kubectl cluster-info When not using the kubectl proxy, we need to authenticate to the API server when sending API requests. We can authenticate by providing a Bearer Token when issuing a curl, or by providing a set of keys and certificates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/ingress/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/ingress/</guid>
      <description>Ingress &amp;quot;An Ingress is a collection of rules that allow inbound connections to reach the cluster Services.&amp;quot;  To allow the inbound connection to reach the cluster Services, Ingress configures a Layer 7 HTTP/HTTPS load balancer for Services and provides the following:
TLS (Transport Layer Security) Name-based virtual hosting Fanout routing Loadbalancing Custom rules.  With Ingress, users do not connect directly to a Service. Users reach the Ingress endpoint, and, from there, the request is forwarded to the desired Service.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/helm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/helm/</guid>
      <description>Helm Helm package manager</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/advanced_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/advanced_tools/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/configMaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/configMaps/</guid>
      <description> ConfigMaps and Secrets </description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/monitoring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/monitoring/</guid>
      <description>Services Monitoring Workflow Services Monitoring Workflow consists of three main components:
Collection agent, Metrics Server, and Dashboards.  Typical workflow, including most common components:
 Monitoring agent collects node metrics. cAdvisor collects containers and pods metrics. Monitoring Aggregation service collects data from its own agent and cAdvisor. Data is stored in the monitoring systemâ€™s storage. Monitoring aggregation service exposes metrics through APIs and dashboards.  A Few Notes:
 Prometheus is the official monitoring server sponsored and incubated by CNCF.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/networking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/networking/</guid>
      <description>About Flanel: https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c
A ServiceAccount is required to login. A ClusterRoleBinding is used to assign the new ServiceAccount (admin-user) the role of cluster-admin on the cluster.
cat &amp;lt;&amp;lt;EOF | kubectl create -f - apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kube-system EOF This means they can control all aspects of Kubernetes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rtfmdev.github.io/docs/kubernetes/volume_types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rtfmdev.github.io/docs/kubernetes/volume_types/</guid>
      <description>Volume Types A directory which is mounted inside a Pod is backed by the underlying Volume Type. A Volume Type decides the properties of the directory, like size, content, default access modes, etc. Some examples of Volume Types are:
emptyDir An empty Volume is created for the Pod as soon as it is scheduled on the worker node. The Volume&amp;rsquo;s life is tightly coupled with the Pod. If the Pod is terminated, the content of emptyDir is deleted forever.</description>
    </item>
    
  </channel>
</rss>